<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Long Drive Simulator By Will Peterson</title>
<style>
body { margin:0; overflow:hidden; background:#87CEEB; font-family:Arial; }
#ui {
  position:absolute;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  width:500px;
  text-align:center;
  color:white;
}
.barContainer {
  width:100%;
  height:18px;
  background:#222;
  border-radius:10px;
  overflow:hidden;
  margin-top:5px;
}
.bar { height:100%; width:0%; }
#powerBar { background:linear-gradient(to right,red,yellow,lime); }
#info { margin-top:8px; font-size:18px; }
#club { position:absolute; top:20px; left:20px; color:white; }
#wind { position:absolute; top:20px; right:20px; color:white; }
</style>
</head>
<body>

<div id="club">Club: Driver (1-3)</div>
<div id="wind">Wind: 0 m/s</div>

<div id="ui">
Power
<div class="barContainer"><div id="powerBar" class="bar"></div></div>
<div id="info">Hold SPACE to swing</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>

// ================= BASIC SETUP =================

let scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87CEEB, 800, 3000);

let camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 5000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);

// COLOR FIX (IMPORTANT)
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.setClearColor(0x87CEEB);

document.body.appendChild(renderer.domElement);

// ================= SKY DOME =================

let skyGeo = new THREE.SphereGeometry(4000, 64, 64);
let skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: {
    topColor: { value: new THREE.Color(0x4da6ff) },
    bottomColor: { value: new THREE.Color(0xffffff) },
    offset: { value: 400 },
    exponent: { value: 0.6 }
  },
  vertexShader: `
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;
    varying vec3 vWorldPosition;
    void main() {
      float h = normalize(vWorldPosition + offset).y;
      gl_FragColor = vec4(mix(bottomColor, topColor, pow(max(h,0.0), exponent)), 1.0);
    }
  `
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

// ================= LIGHTING =================

scene.add(new THREE.HemisphereLight(0xb1e1ff, 0x444422, 0.8));

let sun = new THREE.DirectionalLight(0xffffff, 2);
sun.position.set(300, 500, 200);
sun.castShadow = true;
scene.add(sun);

// ================= TERRAIN =================

let terrainGeo = new THREE.PlaneGeometry(2000,2000,200,200);
terrainGeo.rotateX(-Math.PI/2);

for(let i=0;i<terrainGeo.attributes.position.count;i++){
  let x = terrainGeo.attributes.position.getX(i);
  let z = terrainGeo.attributes.position.getZ(i);
  let y = Math.sin(x*0.01)*10 + Math.cos(z*0.01)*10;
  terrainGeo.attributes.position.setY(i,y);
}
terrainGeo.computeVertexNormals();

let terrain = new THREE.Mesh(
  terrainGeo,
  new THREE.MeshStandardMaterial({
    color:0x2f7d32,
    roughness:0.95,
    metalness:0
  })
);
terrain.receiveShadow = true;
scene.add(terrain);

// ================= BALL =================

let ball = new THREE.Mesh(
  new THREE.SphereGeometry(0.5,32,32),
  new THREE.MeshStandardMaterial({color:0xffffff})
);
ball.castShadow = true;
ball.position.set(0,5,0);
scene.add(ball);

// ================= GAME VARIABLES =================

let velocity = new THREE.Vector3();
let gravity = -30;
let wind = (Math.random()-0.5)*8;

let clubs = {
  Driver:{power:120, loft:0.6},
  Wood:{power:100, loft:0.7},
  Iron:{power:85, loft:0.9}
};

let currentClub="Driver";
updateUI();

function updateUI(){
  document.getElementById("club").innerText="Club: "+currentClub+" (1-3)";
  document.getElementById("wind").innerText="Wind: "+wind.toFixed(1)+" m/s";
}

// ================= CONTROLS =================

let charging=false;
let power=0;
let powerDir=1;
let launched=false;
let aimAngle=0;

document.addEventListener("keydown", e=>{
  if(e.key==="1") currentClub="Driver";
  if(e.key==="2") currentClub="Wood";
  if(e.key==="3") currentClub="Iron";
  if(e.code==="Space" && !launched) charging=true;
  if(e.code==="ArrowLeft") aimAngle+=2;
  if(e.code==="ArrowRight") aimAngle-=2;
  updateUI();
});

document.addEventListener("keyup", e=>{
  if(e.code==="Space" && charging && !launched){
    charging=false;
    shoot();
  }
});

// ================= SHOOT =================

function shoot(){
  launched=true;

  let club=clubs[currentClub];
  let strength=power*club.power;
  let rad=THREE.MathUtils.degToRad(aimAngle);

  velocity.x=Math.sin(rad)*strength;
  velocity.z=-Math.cos(rad)*strength;
  velocity.y=strength*club.loft;

  document.getElementById("info").innerText="SMASH!";
}

// ================= RESET =================

function resetGame(){
  ball.position.set(0,5,0);
  velocity.set(0,0,0);
  launched=false;
  power=0;
  wind=(Math.random()-0.5)*8;
  updateUI();
  document.getElementById("info").innerText="Hold SPACE to swing";
}

// ================= CAMERA =================

camera.position.set(0,25,60);

// ================= LOOP =================

let clock=new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  let delta=clock.getDelta();

  if(charging){
    power+=powerDir*delta;
    if(power>=1){power=1;powerDir=-1;}
    if(power<=0){power=0;powerDir=1;}
    document.getElementById("powerBar").style.width=(power*100)+"%";
  }

  if(launched){
    velocity.y+=gravity*delta;
    velocity.x+=wind*delta;

    ball.position.add(velocity.clone().multiplyScalar(delta));

    camera.position.lerp(
      new THREE.Vector3(
        ball.position.x,
        ball.position.y+30,
        ball.position.z+60
      ),0.05
    );
    camera.lookAt(ball.position);

    if(ball.position.y<=2){
      ball.position.y=2;
      launched=false;

      let dist=Math.sqrt(
        ball.position.x**2+
        ball.position.z**2
      ).toFixed(1);

      document.getElementById("info").innerText="Distance: "+dist+" m";

      setTimeout(resetGame,5000);
    }
  }

  renderer.render(scene,camera);
}

animate();

</script>
</body>
</html>
